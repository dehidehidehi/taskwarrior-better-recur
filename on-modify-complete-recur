#!/usr/bin/env python3

import json
import logging
import sys
import tempfile
import uuid
from datetime import datetime
from typing import TypeVar, Generic, Optional, Callable

from taskw import TaskWarriorShellout

T = TypeVar('T', covariant=True)
U = TypeVar('U', covariant=True)
E = TypeVar('E', bound=BaseException, covariant=True)

class Result(Generic[T, E]):
    """Essentially allows you to capture and delay exception handling."""

    def __init__(self, _callable: Optional[Callable] = None, throwable: Optional[E] = None):
        if _callable is None and throwable is None:
            raise ValueError("_callable and throwable cannot both be none.")
        if _callable is not None and throwable is not None:
            raise ValueError("_callable and throwable cannot both be not none.")
        if throwable:
            self.__value = None
            self.__throwable = throwable
        elif _callable:
            # Apply callable
            try:
                self.__value: Optional[T] = _callable()
                self.__throwable = None
            except Exception as e:
                self.__value = None
                self.__throwable = e

    def __str__(self):
        if self.is_error():
            return str(self.__throwable)
        else:
            return str(self.__value)

    def map(self, function_lambda: Callable[[T], U]) -> 'Result[U, E]':
        if self.is_error():
            return Result.of_error(self.get_error())
        try:
            return Result.of(function_lambda(self.get_value()))
        except Exception as e:
            return Result.of_error(e)

    def get_value(self) -> T:
        if not self.is_error():
            return self.__value
        raise Exception(f"""
        Cannot retrieve value on result with error:
        {self.get_error().__repr__()}
        """)

    def get_error(self) -> Optional[E]:
        if self.is_error():
            return self.__throwable
        raise Exception("Cannot retrieve error on result without error.")

    def is_error(self) -> bool:
        return self.__throwable is not None

    @staticmethod
    def of_error(error: E) -> 'Result[T, E]':
        return Result(None, error)

    @staticmethod
    def of(_callable: Callable) -> 'Result[T, E]':
        return Result(_callable, None)


class TaskWarriorHook:

    TIME_FORMAT = "%Y%m%dT%H%M%SZ"
    UDA_DUE = "crdue"
    UDA_WAIT = "crwait"

    def __init__(self, original: dict, modified: dict):
        self._original = original
        self._modified = modified
        self._tw = TaskWarriorShellout(
            marshal=False,
            config_overrides={
                'rc.verbose': 'nothing',
                'rc.date.iso': 'yes',
            }
        )
        self._logger = self._make_silent_logger()

    def main(self) -> None:
        try:
            self._logger.info("Original: " + str(self._original))
            self._logger.info("Modified: " + str(self._modified))
            original = self._original
            modified = Result.of(lambda: self._tw.task_update(self._modified))
            if modified.is_error():
                self._logger.exception(modified.get_error())
                print(modified.get_error())
                exit(1)

            modified = modified.get_value()
            print(bytes(modified))

            if (
                    (self.UDA_DUE in original or self.UDA_WAIT in original)
                    and original["status"] != "completed"
                    and modified["status"] == "completed"
            ):
                del original["modified"]
                if "start" in original:
                    del original["start"]
                if self.UDA_DUE in original:
                    original["due"] = self.calc(original[self.UDA_DUE])
                if self.UDA_WAIT in original:
                    original["wait"] = self.calc(original[self.UDA_WAIT])
                    original["status"] = "waiting"
                else:
                    original["status"] = "pending"

                print("Created follow-up task")

                original["entry"] = modified["end"]
                original["uuid"] = str(uuid.uuid4())

                result = Result.of(lambda: self._tw.task_add(original))
                if result.is_error():
                    self._logger.exception(result.get_error())
                    print(result.get_error())
                    exit(1)
            exit(0)
        except Exception as e:
            self._logger.exception(e)
            print(e)
            exit(1)

    def calc(self, statement) -> str:
        """ Hand back duration format parsing to task warrior """
        stdout, stdin = self._tw._execute(*["calc", statement])
        return stdout

    def _make_silent_logger(self) -> logging.Logger:
        """Only writes to a file, does not print anything to stdout."""
        logger = logging.getLogger('on-modify-complete-recur')
        logger.setLevel(logging.DEBUG)
        file_handler = logging.FileHandler(
            f"{tempfile.gettempdir()}/on-modify-complete-recur-{datetime.now().strftime('%Y-%m-%d')}.log")
        file_handler.setLevel(logging.DEBUG)
        file_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
        logger.addHandler(file_handler)
        logger.propagate = False
        return logger


original = json.loads(sys.stdin.readline())
modified = json.loads(sys.stdin.readline())
sys.stdin.close()
TaskWarriorHook(original=original, modified=modified).main()

# if __name__ == '__main__':
#     tw_hook = TaskWarriorHook(None, None)
#     result = tw_hook.calc("tomorrow")
#     print(result)
